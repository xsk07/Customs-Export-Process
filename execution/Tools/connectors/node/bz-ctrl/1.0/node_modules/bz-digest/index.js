/**
 * @author JarveinR
 */

var crypto = require('crypto');
var url = require('url');
var request = require('request');
var NONCES = {};

var HTTPDigest = function () {

    var HTTPDigest = function () {
    };

    HTTPDigest.prototype.getAuthParamsFromChallenge = function (username, password, requestOptions, callback) {
        var self = this;
        request(requestOptions, function (error, response, body) {
            if (error){
                callback({error: JSON.stringify(error)});
            }
            else{
                self._handleResponse(username, password, requestOptions, response, callback);
            }
        });
    };

    HTTPDigest.prototype._handleResponse = function handleResponse(username, password, options, res, callback) {
        var challenge = this._parseChallenge(res.headers['www-authenticate']);
        if (challenge) {
            // Setup response parameters
            var authParams = {
                username: username,
                realm: challenge.realm,
                nonce: challenge.nonce
            };

            if (challenge.opaque){
                authParams.opaque = challenge.opaque;
            }

            if (challenge.algorithm && challenge.algorithm.indexOf('MD5-sess') >= 0){
                authParams.algorithm = 'MD5-sess';
            }
            else{
                authParams.algorithm = 'MD5';
            }

            if (challenge.qop && challenge.qop.indexOf('auth-int') >= 0){
                // TODO: Implement support for auth-int.  Note that the raw entity body
                //       will be needed, not the parsed req.body property set by Connect's
                //       bodyParser middleware.
                //
                //       See RFC 2617 (Section 3.2.2.3 and Section 3.2.2.4) for further
                //       details.
                callback({error: 'auth-int qop not implemented'});
                return;
            }
            else if (challenge.qop && challenge.qop.indexOf('auth') >= 0){
                challenge.qop = 'auth';
            }

            // Generate cnonce
            var cnonce = null;
            if (challenge.qop) {
                var cnonceHash = crypto.createHash('md5').update(Math.random().toString(36));
                cnonce = cnonceHash.digest('hex').substr(0, 8);
                authParams.cnonce = cnonce;
                authParams.qop = challenge.qop;
            }

            var a1 = '';
            if (authParams.algorithm == 'MD5-sess' && cnonce){
                var a1Part = [username, challenge.realm, password].join(':');
                a1 = [crypto.createHash('md5').update(a1Part).digest('hex'), challenge.nonce, cnonce].join(':');
            }
            else{
                a1 = [username, challenge.realm, password].join(':');
            }

            var ha1 = crypto.createHash('md5').update(a1).digest('hex');
            authParams.ha1 = ha1;

            callback(null, authParams);
        }
        else {
            callback({error:'The server not support Digest Authentication challenge'});
        }
    };

    HTTPDigest.prototype.getAuthorizationHeader = function getAuthorizationHeader(params, callback) {
        var ha2 = '';
        var path = url.parse(params.uri).pathname;
        if (!params.qop || params.qop == 'auth'){
            var a2 = [params.method, path].join(':');
            ha2 = crypto.createHash('md5').update(a2).digest('hex');
        }
        else{
            // TODO: Implement support for auth-int.  Note that the raw entity body
            //       will be needed, not the parsed req.body property set by Connect's
            //       bodyParser middleware.
            //
            //       See RFC 2617 (Section 3.2.2.3 and Section 3.2.2.4) for further
            //       details.
            callback({error: 'auth-int qop not implemented'});
            return;
        }
        params.ha2 = ha2;
        params.nc = this.getNC(params.nonce);

        params.response = this._calculeResponse(params);

        var authorization = 'Digest ' +
                            'username="' + params.username + '",' +
                            'realm="' + params.realm + '",' +
                            'nonce="' + params.nonce  + '",' +
                            'uri="' + path  + '",' +
                            'response="' + params.response  + '",' +
                            'algorithm=' + params.algorithm;

        if (params.opaque){
            authorization += ',opaque="' + params.opaque + '"';
        }

        if (params.qop){
            authorization += ',qop=' + params.qop;
        }

        if (params.cnonce){
            authorization += ',nc=' + params.nc;
            authorization += ',cnonce="' + params.cnonce + '"';
        }

        callback(null, {authorization: authorization});
    };


    HTTPDigest.prototype._calculeResponse = function parseChallenge(authParams) {
        var responseParams = [
            authParams.ha1,
            authParams.nonce
        ];

        if (authParams.qop) {
            responseParams.push(authParams.nc);
            responseParams.push(authParams.cnonce);
            responseParams.push(authParams.qop);
        }
        responseParams.push(authParams.ha2);

        var response = crypto.createHash('md5');
        response.update(responseParams.join(':'));

        return response.digest('hex');
    }

    //
    // ## Parse challenge digest
    //
    HTTPDigest.prototype._parseChallenge = function parseChallenge(digest) {
        if (digest && digest.indexOf("Digest ") >= 0) {
            var challenge = digest.substr(digest.indexOf("Digest ") + "Digest ".length);

            var params = {};

            params['realm'] = this._extractQuotedValue('realm', challenge);
            params['nonce'] = this._extractQuotedValue('nonce', challenge);

            if (challenge.indexOf("domain") >= 0){
                params['domain'] = this._extractQuotedValue('domain', challenge);
            }

            if (challenge.indexOf("opaque") >= 0){
                params['opaque'] = this._extractQuotedValue('opaque', challenge);
            }

            if (challenge.indexOf("stale") >= 0){
                params['stale'] = this._extractUnquotedValue('stale', challenge);
            }

            if (challenge.indexOf("algorithm") >= 0){
                params['algorithm'] = this._extractUnquotedValue('algorithm', challenge);
            }

            if (challenge.indexOf("qop") >= 0){
                params['qop'] = this._extractQuotedValue('qop', challenge);
            }

            return params;
        }
        else{
            return null;
        }
    };

    HTTPDigest.prototype._extractQuotedValue = function extractQuotedValue(key, source) {
        var start = source.indexOf(key);
        var end = source.indexOf('",', start);
        if (end < 0){
            end = source.length - 1;
        }

        var value = source.substring(start, end);
        value = value.split('=');
        return value[1].substr(1);
    };

    HTTPDigest.prototype._extractUnquotedValue = function extractUnquotedValue(key, source) {
        var start = source.indexOf(key);
        var end = source.indexOf(',', start);
        if (end < 0){
            end = source.length - 1;
        }
        var value = source.substring(start, end);
        value = value.split('=');
        return value[1].substr(0);
    };


    HTTPDigest.prototype.getNC = function getNC(nonce) {
        var max = 99999999;
        var nc = NONCES[nonce];
        if (nc){
            nc++;
        }
        else{
            nc = 1;
        }

        NONCES[nonce] = nc;

        if (nc > max) {
            nc = 1;
        }
        nc = nc + "";
        var padding = new Array(8).join('0') + "";
        return padding.substr(0, 8 - nc.length) + nc + "";
    };

    // Return response handler
    return HTTPDigest;
}();

exports.create = function create(username, password) {
    return new HTTPDigest(username, password);
};