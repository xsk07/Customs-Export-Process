var querystring= require('querystring');
var crypto= require('crypto');
var https= require('https');
var http= require('http');
var URL= require('url');
var OAuthUtils= require('./_utils');

exports.OAuth2= function(customHeaders) {  
  this._accessTokenName= "access_token";
  this._authMethod= "Bearer";  
  this._useAuthorizationHeaderForGET= false;
}

// This 'hack' method is required for sites that don't use
// 'access_token' as the name of the access token (for requests).
// ( http://tools.ietf.org/html/draft-ietf-oauth-v2-16#section-7 )
// it isn't clear what the correct value should be atm, so allowing
// for specific (temporary?) override for now.
exports.OAuth2.prototype.setAccessTokenName= function ( name ) {
  this._accessTokenName= name;
}

// Sets the authorization method for Authorization header.
// e.g. Authorization: Bearer <token>  # "Bearer" is the authorization method.
exports.OAuth2.prototype.setAuthMethod = function ( authMethod ) {
  this._authMethod = authMethod;
};


// If you use the OAuth2 exposed 'get' method (and don't construct your own _request call )
// this will specify whether to use an 'Authorize' header instead of passing the access_token as a query parameter
exports.OAuth2.prototype.useAuthorizationHeaderforGET = function(useIt) {
  this._useAuthorizationHeaderForGET= useIt;
}


// Build the authorization header. In particular, build the part after the colon.
// e.g. Authorization: Bearer <token>  # Build "Bearer <token>"
exports.OAuth2.prototype.buildAuthHeader= function(token) {
  return this._authMethod + ' ' + token;
};

exports.OAuth2.prototype._chooseHttpLibrary= function( parsedUrl ) {
  var http_library= https;
  // As this is OAUth2, we *assume* https unless told explicitly otherwise.
  if( parsedUrl.protocol != "https:" ) {
    http_library= http;
  }
  return http_library;
};

exports.OAuth2.prototype._request= function(method, url, headers, post_body, access_token, enableHttpsVerification, callback) {

  var creds = crypto.createCredentials({ });
  var parsedUrl= URL.parse( url, true );
  if( parsedUrl.protocol == "https:" && !parsedUrl.port ) {
    parsedUrl.port= 443;
  }

  var http_library= this._chooseHttpLibrary( parsedUrl );

  var headers= headers || {};  
  
  headers['Host']= parsedUrl.host;

  if (!headers['User-Agent']) {
    headers['User-Agent'] = 'Node-oauth';
  }

  if( post_body ) {
      if ( Buffer.isBuffer(post_body) ) {
          headers["Content-Length"]= post_body.length;
      } else {
          headers["Content-Length"]= Buffer.byteLength(post_body);
      }
  } else {
      headers["Content-length"]= 0;
  }

  if( access_token && !('Authorization' in headers)) {
    if( !parsedUrl.query ){ 
        parsedUrl.query= {};
    }
    parsedUrl.query[this._accessTokenName]= access_token;
  }

  var queryStr= querystring.stringify(parsedUrl.query);
  if( queryStr ){
      queryStr=  "?" + queryStr;
  }

    enableHttpsVerification = enableHttpsVerification ? enableHttpsVerification : false;

    var options = {
        host: parsedUrl.hostname,
        port: parsedUrl.port,
        path: parsedUrl.pathname + queryStr,
        method: method,
        headers: headers,
        rejectUnauthorized: enableHttpsVerification
    };

    this._executeRequest( http_library, options, post_body, callback );
}

exports.OAuth2.prototype._executeRequest= function( http_library, options, post_body, callback ) {
    // Some hosts *cough* google appear to close the connection early / send no content-length header
    // allow this behaviour.
    var allowEarlyClose= OAuthUtils.isAnEarlyCloseHost(options.host);
    var callbackCalled= false;
    
    function passBackControl( response, result ) {
        if(!callbackCalled) {            
            callbackCalled=true;

            if(response.statusCode == 401) {                
                callback({ statusCode: response.statusCode, error: 'User unauthorized' }, null, null);
                return;
            }
            else if(response.statusCode == 404) { 
                var url = options.hostname || options.host;
                url = url + (options.port ? ':' + options.port : '') + options.path;
                callback({ statusCode: response.statusCode, error: 'Resource not found: ' +  url}, null, null);
                return;
            }
            else if( response.statusCode != 200 && (response.statusCode != 301) && (response.statusCode != 302) ) {
                callback({ statusCode: response.statusCode, error: result }, null, null);
                return;
            }                 
            else {            
                callback(null, result, response);
                return;
            }
        }
    }
    
    var result= "";

    var request = http_library.request(options, function (response) {
        response.on("data", function (chunk) {
            result+= chunk
        });
        response.on("close", function (err) {
            if( allowEarlyClose ) {
                passBackControl( response, result );
        }});
        response.addListener("end", function () {
            passBackControl( response, result );
        });
    });
    
    request.on('error', function(e) {        
        callbackCalled= true;
        callback(e);
    });

    if( (options.method == 'POST' || options.method == 'PUT') && post_body ) {
        request.write(post_body);
    }
    request.end();
}

exports.OAuth2.prototype.getAuthorizeUrl= function( params ) {
  var params= params || {};
  params['client_id'] = this._clientId;
  return this._authorizeUrl + "?" + querystring.stringify(params);
}

exports.OAuth2.prototype.clientCredentialsFlow = function(token_url, client_id, client_secret, scope, params, headers, enableHttpsVerification, callback) {
    var headers = headers || {};
    var params= params || {};
        
    params['grant_type'] = 'client_credentials';    
    params['client_id'] = client_id;
    params['client_secret'] = client_secret;    
    if (scope){
        params['scope'] = scope;
    }        
    var post_data= querystring.stringify( params );
    
    var authorization = new Buffer(client_id + ":" + client_secret).toString('base64');
	authorization = "Basic " + authorization;
    headers['Content-Type'] = 'application/x-www-form-urlencoded';
    headers['Authorization'] = authorization;

    this._request("POST", token_url, headers, post_data, null, enableHttpsVerification, function(error, data, response) {
        if( error ){              
            callback(error, null, null, null, null);
        }
        else {
            var results;
            try {
                // As of http://tools.ietf.org/html/draft-ietf-oauth-v2-07
                // responses should be in JSON
                results= JSON.parse( data );
            }
            catch(e) {
                // .... However both Facebook + Github currently use rev05 of the spec
                // and neither seem to specify a content-type correctly in their response headers :(
                // clients of these services will suffer a *minor* performance cost of the exception
                // being thrown
                results= querystring.parse( data );
            }
            var statusCode = response.statusCode;
            var access_token= results["access_token"];
            var token_type= results["token_type"];
            var expires_in= results["expires_in"];            
            callback(null, results, statusCode, access_token, token_type, expires_in, statusCode); // callback results =-=
        }
    });
}

exports.OAuth2.prototype.resourceOwnerPasswordCredentialsFlow= function(token_url, username, password, scope, params, headers, enableHttpsVerification, callback) {
    var headers = headers || {};
    var params= params || {};
        
    params['response_type'] = 'password';    
    params['username'] = username;
    params['password'] = password;    
    if (scope){
        params['scope'] = scope;
    }
           
    var post_data= querystring.stringify( params );
        
    var authorization = new Buffer(username + ":" + password).toString('base64');
	authorization = "Basic " + authorization;
    headers['Content-Type'] = 'application/x-www-form-urlencoded';
    headers['Authorization'] = authorization;
    
    this._request("POST", token_url, headers, post_data, null, enableHttpsVerification, function(error, data, response) {
        if( error ){            
            callback(error, null, null, null, null);
        }
        else {            
            var results;
            try {
                // As of http://tools.ietf.org/html/draft-ietf-oauth-v2-07
                // responses should be in JSON
                results= JSON.parse( data );
            }
            catch(e) {
                // .... However both Facebook + Github currently use rev05 of the spec
                // and neither seem to specify a content-type correctly in their response headers :(
                // clients of these services will suffer a *minor* performance cost of the exception
                // being thrown
                results= querystring.parse( data );
            }
            var statusCode = response.statusCode;
            var access_token= results["access_token"];
            var refresh_token= results["refresh_token"];
            var token_type= results["token_type"];
            var expires_in= results["expires_in"];            
            callback(null, results, statusCode, access_token, refresh_token, token_type, expires_in); // callback results =-=
        }
    });
}
